"""
Helper functions for managing video metadata
"""
import subprocess
from pathlib import Path
from datetime import datetime


def add_youtube_shorts_metadata(video_path: str, output_path: str, 
                                 title: str = None, subreddit: str = None, 
                                 text_snippet: str = None):
    """
    Add YouTube Shorts optimized metadata for better algorithm performance.
    
    YouTube's algorithm uses metadata to:
    - Understand content category
    - Match with interested viewers
    - Generate search keywords
    - Suggest to relevant audiences
    - Optimize thumbnail/title testing
    
    Args:
        video_path: Input video path
        output_path: Output video path
        title: Story title (for metadata)
        subreddit: Source subreddit
        text_snippet: First part of story for description
    """
    
    # Build optimized metadata for YouTube Shorts
    metadata = {}
    
    # Title - Critical for algorithm
    if title:
        # Clean title for metadata (YouTube limits)
        clean_title = title[:100].strip()
        metadata['title'] = clean_title
    else:
        metadata['title'] = 'Reddit Story'
    
    # Description - Important for SEO and recommendations
    description_parts = []
    if text_snippet:
        description_parts.append(text_snippet.strip() + '...')
    if subreddit:
        description_parts.append(f'\nFrom r/{subreddit}')
    
    description_parts.extend([
        '\n\n#RedditStories #Shorts #Storytelling',
        '\n\nðŸ”” Subscribe for more stories!',
    ])
    
    metadata['description'] = ''.join(description_parts)
    metadata['comment'] = ''.join(description_parts)  # Fallback field
    
    # Genre - Helps algorithm categorize
    metadata['genre'] = 'Entertainment'
    
    # Artist/Creator - Branding
    metadata['artist'] = 'Narrify'
    metadata['album'] = 'Reddit Stories'
    
    # Date - Freshness signal for algorithm
    metadata['date'] = datetime.now().strftime('%Y%m%d')
    metadata['year'] = datetime.now().strftime('%Y')
    
    # Copyright - Professional appearance
    metadata['copyright'] = f'Â© {datetime.now().year} Narrify'
    
    # Keywords for discoverability
    keywords = ['reddit', 'stories', 'shorts']
    if subreddit:
        keywords.append(subreddit.lower())
    metadata['keywords'] = ', '.join(keywords)
    
    # Add metadata to video
    cmd = ['ffmpeg', '-y', '-i', video_path]
    
    for key, value in metadata.items():
        # Escape special characters for shell
        safe_value = str(value).replace('\\', '\\\\').replace('"', '\\"')
        cmd.extend(['-metadata', f'{key}={safe_value}'])
    
    cmd.extend([
        '-c', 'copy',  # Copy streams without re-encoding
        '-movflags', '+faststart',  # Optimize for web streaming
        output_path
    ])
    
    try:
        subprocess.check_call(cmd)
        print(f"âœ… Added YouTube Shorts optimized metadata")
        return output_path
    except subprocess.CalledProcessError as e:
        # If faststart fails due to space, try without it
        print(f"âš ï¸ Warning: faststart failed (possibly low disk space), retrying without it...")
        cmd_no_faststart = ['ffmpeg', '-y', '-i', video_path]
        
        for key, value in metadata.items():
            safe_value = str(value).replace('\\', '\\\\').replace('"', '\\"')
            cmd_no_faststart.extend(['-metadata', f'{key}={safe_value}'])
        
        cmd_no_faststart.extend([
            '-c', 'copy',  # Copy streams without re-encoding
            output_path
        ])
        
        subprocess.check_call(cmd_no_faststart)
        print(f"âœ… Added metadata (without faststart optimization)")
        return output_path


def add_custom_metadata(video_path: str, output_path: str, metadata: dict):
    """
    Add custom metadata to a video file.
    
    Args:
        video_path: Input video path
        output_path: Output video path
        metadata: Dictionary of metadata key-value pairs
        
    Common metadata keys:
        - title: Video title
        - artist: Creator/channel name
        - comment: Description or comment
        - description: Full description
        - date: Publication date (YYYYMMDD)
        - genre: Content genre
    
    Example:
        add_custom_metadata(
            'input.mp4',
            'output.mp4',
            {
                'title': 'My Reddit Story',
                'artist': 'Narrify',
                'comment': 'Generated by Narrify',
                'date': '20250101'
            }
        )
    """
    cmd = ['ffmpeg', '-y', '-i', video_path]
    
    # Add metadata flags
    for key, value in metadata.items():
        cmd.extend(['-metadata', f'{key}={value}'])
    
    cmd.extend([
        '-c', 'copy',  # Copy streams without re-encoding
        output_path
    ])
    
    subprocess.check_call(cmd)
    return output_path


def strip_all_metadata(video_path: str, output_path: str):
    """
    Strip all metadata from a video file.
    
    Args:
        video_path: Input video path
        output_path: Output video path with no metadata
    """
    cmd = [
        'ffmpeg', '-y',
        '-i', video_path,
        '-map_metadata', '-1',  # Remove all metadata
        '-fflags', '+bitexact',  # Remove encoder info
        '-c', 'copy',  # Copy streams without re-encoding
        output_path
    ]
    
    subprocess.check_call(cmd)
    return output_path


def view_metadata(video_path: str) -> dict:
    """
    View all metadata from a video file.
    
    Args:
        video_path: Path to video file
        
    Returns:
        Dictionary of metadata key-value pairs
    """
    import json
    
    cmd = [
        'ffprobe',
        '-v', 'error',
        '-show_entries', 'format_tags',
        '-of', 'json',
        video_path
    ]
    
    result = subprocess.check_output(cmd)
    data = json.loads(result)
    
    if 'format' in data and 'tags' in data['format']:
        return data['format']['tags']
    return {}


def create_youtube_metadata(title: str, story: str, subreddit: str, reddit_url: str) -> dict:
    """
    Create YouTube upload metadata from Reddit post.
    
    Args:
        title: Reddit post title
        subreddit: Subreddit name
        story: Story content
        reddit_url: Original Reddit URL
        
    Returns:
        Dictionary with title, description, and tags
    """
    # Create description
    description_parts = [
        story[:500].strip() + ('...' if len(story) > 500 else ''),
        '',
        f'From r/{subreddit}',
        f'Original: {reddit_url}',
        '',
        '#RedditStories #Shorts #Storytelling #' + subreddit,
        '',
        'ðŸ”” Subscribe for more stories!'
    ]
    
    # Create tags
    tags = [
        'reddit',
        'stories',
        'shorts',
        'storytelling',
        subreddit.lower(),
        'reddit stories',
        'reddit shorts'
    ]
    
    return {
        'title': title,
        'description': '\n'.join(description_parts),
        'tags': tags
    }
